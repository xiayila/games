<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Canvas æ±‰è¯ºå¡”</title>
<style>
body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  margin: 0;
  background-color: #f0f4f8; 
}
.container {
  background-color: #ffffff;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
  text-align: center;
}
h1 {
  color: #4a148c;
  margin: 0; 
}
#hanoiCanvas {
  border: 1px solid #ccc;
  background-color: #e0e6ed; 
  margin-bottom: 20px;
  cursor: pointer;
}
.controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 800px; 
  padding: 10px;
  margin-bottom: 15px;
}
.setting, .status {
  display: flex;
  align-items: center;
  font-size: 16px;
  color: #555;
}
input[type="number"] {
  padding: 8px;
  width: 50px;
  text-align: center;
  border: 1px solid #a0a0a0;
  border-radius: 4px;
  margin: 0 10px;
}
button {
  padding: 10px 15px;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  transition: background-color 0.3s;
  margin-left: 10px;
}
button:hover {
  background-color: #0056b3;
}
.message {
  color: #008000;
  font-size: 1.2em;
  font-weight: bold;
  height: 30px;
}
</style>
</head>
<body>

<div class="container">
  <h1>ğŸ—¼ Canvas æ±‰è¯ºå¡”</h1>
  
  <div class="controls">
    <div class="setting">
      <label for="diskCountInput">ç›˜å­æ•°é‡ (1-10):</label>
      <input type="number" id="diskCountInput" value="1" min="1" max="10">
      <button id="resetBtn" onclick="hanoiGame.resetGame(document.getElementById('diskCountInput').value)">å¼€å§‹æ¸¸æˆ/é‡ç½®</button>
      <button id="solveBtn" onclick="hanoiGame.solveAutomatically()">è‡ªåŠ¨å®Œæˆ</button>
    </div>
    <div class="status">
        <p>å½“å‰ç›˜æ•°: <span id="currentDisks">1</span> | </p>
      <p>æ­¥æ•°: <span id="moveCount">0</span> | </p>
      <p>æœ€å°æ­¥æ•°: <span id="minMoves">1</span></p>
    </div>
  </div>

  <canvas id="hanoiCanvas" width="800" height="450"></canvas>

  <div id="message" class="message"></div>
</div>

<script>
// --- æ±‰è¯ºå¡” Canvas æ¸¸æˆæ ¸å¿ƒé€»è¾‘ ---
class HanoiGame {
    constructor() {
        this.canvas = document.getElementById('hanoiCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // ç»˜å›¾å°ºå¯¸å¸¸é‡
        this.CANVAS_WIDTH = 800;
        this.CANVAS_HEIGHT = 450; 
        this.BASE_HEIGHT = 40; 
        this.POLE_WIDTH = 18; 
        this.DISK_HEIGHT = 40; 
        
        this.TOP_MARGIN = 30; 

        // æ¸¸æˆçŠ¶æ€
        this.diskCount = 1;
        this.towers = [[], [], []];
        this.moveCount = 0;
        this.isAnimating = false;
        this.isSolving = false; // è·Ÿè¸ªè‡ªåŠ¨æ¼”ç®—çŠ¶æ€
        
        // äº¤äº’çŠ¶æ€
        this.selectedTower = -1;
        this.selectedDiskSize = 0;
        
        // åŠ¨ç”»çŠ¶æ€
        this.animation = null;
        this.animationDuration = 300; 

        // é¢œè‰²å’Œå…ƒç´ ä½ç½®
        this.POLE_X = [
            this.CANVAS_WIDTH * 0.2, 
            this.CANVAS_WIDTH * 0.5, 
            this.CANVAS_WIDTH * 0.8  
        ];
        this.POLE_NAMES = ['A', 'B', 'C']; 
        this.BASE_BOTTOM_Y = this.CANVAS_HEIGHT;
        this.STACK_START_Y = this.CANVAS_HEIGHT - this.BASE_HEIGHT; 
        this.POLE_START_Y = this.STACK_START_Y; 
        this.POLE_RADIUS = 9; 
        
        this.POLE_TOP_Y = this.TOP_MARGIN;
        this.POLE_HEIGHT = this.STACK_START_Y - this.POLE_TOP_Y;

        // æ–°çš„ç›˜å­é…è‰²æ–¹æ¡ˆ
        this.colors = [
            '#ff6347', // 1å·ç›˜ (æœ€å°ç›˜)
            '#ff8c00', // 2å·ç›˜
            '#ffd700', // 3å·ç›˜
            '#adff2f', // 4å·ç›˜
            '#00ced1', // 5å·ç›˜
            '#4169e1', // 6å·ç›˜
            '#8a2be2', // 7å·ç›˜
            '#ff69b4',  // 8å·ç›˜
            '#C0C0C0',  // 9å·ç›˜
            '#800000'   // 10å·ç›˜ (æœ€å¤§ç›˜)
        ];
        
        // DOM å¼•ç”¨
        this.dom = {
            count: document.getElementById('moveCount'),
            min: document.getElementById('minMoves'),
            current: document.getElementById('currentDisks'),
            msg: document.getElementById('message'),
            input: document.getElementById('diskCountInput'),
            resetBtn: document.getElementById('resetBtn'),
            solveBtn: document.getElementById('solveBtn'),
        };

        this.canvas.addEventListener('click', this.handleCanvasClick.bind(this));
        
        this.resetGame(this.diskCount);
        this.gameLoop();
    }
    
    // --- ç»˜å›¾å‡½æ•° ---
    drawBase() {
        this.ctx.fillStyle = '#6d4c41'; 
        this.ctx.fillRect(0, this.STACK_START_Y, this.CANVAS_WIDTH, this.BASE_HEIGHT);
    }

    drawPole(index) {
        const x = this.POLE_X[index];
        const x0 = x - this.POLE_WIDTH / 2;
        const x1 = x + this.POLE_WIDTH / 2;
        const y0 = this.POLE_TOP_Y;
        const y1 = this.POLE_START_Y;
        const r = this.POLE_RADIUS;
        
        this.ctx.fillStyle = '#455a64'; 
        
        // ç»˜åˆ¶åœ†è§’é¡¶éƒ¨ç«‹æŸ±
        this.ctx.beginPath();
        this.ctx.moveTo(x0, y1);
        this.ctx.lineTo(x0, y0 + r);
        this.ctx.arcTo(x0, y0, x0 + r, y0, r);
        this.ctx.lineTo(x1 - r, y0);
        this.ctx.arcTo(x1, y0, x1, y0 + r, r);
        this.ctx.lineTo(x1, y1);
        this.ctx.closePath();
        this.ctx.fill();

        // ç»˜åˆ¶æŸ±å­åç§° (A, B, C) åœ¨åº•åº§ä¸Š
        this.ctx.fillStyle = '#ffc107'; 
        this.ctx.font = 'bold 24px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle'; 
        this.ctx.fillText(
            this.POLE_NAMES[index], 
            x, 
            this.STACK_START_Y + this.BASE_HEIGHT / 2 
        );
    }

    drawDisk(size, towerIndex, positionIndex) {
        const maxDiskWidth = 200;
        const minDiskWidth = 80;
        
        let width;
        if (this.diskCount > 1) {
            width = minDiskWidth + (maxDiskWidth - minDiskWidth) * (size - 1) / (this.diskCount - 1);
        } else {
            width = maxDiskWidth; 
        }
        
        const x = this.POLE_X[towerIndex];
        const y = this.STACK_START_Y - (positionIndex + 1) * this.DISK_HEIGHT; 

        this.ctx.fillStyle = this.colors[size - 1]; 
        
        // ç»˜åˆ¶ç›˜å­æœ¬ä½“ (æ— ç¼éš™ï¼Œæ— æè¾¹)
        this.ctx.beginPath();
        this.ctx.roundRect(x - width / 2, y, width, this.DISK_HEIGHT, 5); 
        this.ctx.fill();

        // ç»˜åˆ¶ç›˜å­ç¼–å·
        this.ctx.fillStyle = '#ffffff'; 
        this.ctx.font = 'bold 18px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(
            size.toString(), 
            x, 
            y + (this.DISK_HEIGHT / 2)
        );

        // é€‰ä¸­é«˜äº® (ä¿ç•™)
        if (towerIndex === this.selectedTower && positionIndex === this.towers[towerIndex].length - 1) {
            this.ctx.strokeStyle = 'yellow';
            this.ctx.lineWidth = 3;
            this.ctx.stroke();
        }
    }

    drawScene() {
        this.ctx.clearRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT);
        
        this.drawBase();

        for (let i = 0; i < 3; i++) {
            this.drawPole(i);

            this.towers[i].forEach((size, index) => {
                this.drawDisk(size, i, index);
            });
        }
        
        if (this.animation) {
            this.drawAnimatedDisk();
        }
    }
    
    // --- åŠ¨ç”»ç»˜åˆ¶ ---
    drawAnimatedDisk() {
        const anim = this.animation;
        if (!anim) return;

        const progress = (Date.now() - anim.startTime) / this.animationDuration;
        
        let t = Math.min(1, progress);
        
        const startY = this.STACK_START_Y - (anim.startPos + 1) * this.DISK_HEIGHT;
        const endY = this.STACK_START_Y - (anim.endPos + 1) * this.DISK_HEIGHT;
        const topY = this.POLE_TOP_Y - 30; 
        
        const startX = this.POLE_X[anim.startTower];
        const endX = this.POLE_X[anim.endTower];
        
        let currentX, currentY;

        if (t < 0.33) { 
            let p = t / 0.33;
            currentX = startX;
            currentY = startY + (topY - startY) * p;

        } else if (t < 0.66) { 
            let p = (t - 0.33) / 0.33;
            currentX = startX + (endX - startX) * p;
            currentY = topY;

        } else { 
            let p = (t - 0.66) / 0.34;
            currentX = endX;
            currentY = topY + (endY - topY) * p;
        }
        
        // ç»˜åˆ¶åŠ¨ç”»ä¸­çš„ç›˜å­
        const size = anim.diskSize;
        const maxDiskWidth = 200;
        const minDiskWidth = 80;
        
        let width;
        if (this.diskCount > 1) {
            width = minDiskWidth + (maxDiskWidth - minDiskWidth) * (size - 1) / (this.diskCount - 1);
        } else {
            width = maxDiskWidth; 
        }
        
        this.ctx.fillStyle = this.colors[size - 1]; 
        
        this.ctx.beginPath();
        this.ctx.roundRect(currentX - width / 2, currentY, width, this.DISK_HEIGHT, 5);
        this.ctx.fill();
        
        // ç»˜åˆ¶åŠ¨ç”»ç›˜å­çš„ç¼–å·
        this.ctx.fillStyle = '#000000'; 
        this.ctx.font = 'bold 18px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(
            size.toString(), 
            currentX, 
            currentY + (this.DISK_HEIGHT / 2)
        );

        // åŠ¨ç”»ç»“æŸ
        if (progress >= 1) {
            this.animation = null;
            this.isAnimating = false;
            
            this.checkWin();
        }
    }

    gameLoop() {
        this.drawScene();
        requestAnimationFrame(this.gameLoop.bind(this));
    }

    // --- æ¸¸æˆé€»è¾‘ ---

    resetGame(n) {
        if (this.isSolving) {
            this.dom.msg.textContent = 'æ­£åœ¨è‡ªåŠ¨æ¼”ç®—ï¼Œè¯·ç¨åå†è¯•ã€‚';
            return;
        }
        const defaultDisks = 1; 
        const newDiskCount = Math.min(Math.max(parseInt(n) || defaultDisks, 1), 10); 
        this.diskCount = newDiskCount;
        
        this.towers = [[], [], []];
        for (let i = this.diskCount; i >= 1; i--) {
            this.towers[0].push(i);
        }

        this.selectedTower = -1;
        this.selectedDiskSize = 0;
        this.moveCount = 0;
        this.isAnimating = false;
        this.animation = null;

        this.dom.count.textContent = this.moveCount;
        this.dom.min.textContent = Math.pow(2, this.diskCount) - 1;
        this.dom.current.textContent = this.diskCount;
        this.dom.input.value = this.diskCount;
        this.dom.msg.textContent = `å°†æ‰€æœ‰ç›˜å­ä» ${this.POLE_NAMES[0]} æŸ±ç§»åŠ¨åˆ° ${this.POLE_NAMES[2]} æŸ±ã€‚`;
        
        this.drawScene();
    }

    checkWin() {
        const isWin = this.towers[2].length === this.diskCount;

        if (isWin) {
            this.dom.msg.textContent = `ğŸ‰ æ­å–œï¼ç”¨ ${this.moveCount} æ­¥å®Œæˆäº† ${this.diskCount} ä¸ªç›˜å­çš„æ±‰è¯ºå¡”ã€‚`;

            if (this.diskCount < 10) {
                setTimeout(() => {
                    const nextDiskCount = this.diskCount + 1;
                    this.dom.msg.textContent = `å³å°†å‡çº§åˆ° ${nextDiskCount} ä¸ªç›˜å­çš„æ–°æ¸¸æˆ...`;
                    this.resetGame(nextDiskCount);
                }, 3000); 
            } else {
                this.dom.msg.textContent += ' å·²å®Œæˆæœ€é«˜éš¾åº¦ï¼ˆ10ä¸ªç›˜å­ï¼‰ï¼';
            }
        }
    }

    // --- äº¤äº’å¤„ç† (ä¼˜åŒ–å) ---
    handleCanvasClick(event) {
        if (this.isAnimating || this.isSolving) {
            this.dom.msg.textContent = 'è¯·ç­‰å¾…è‡ªåŠ¨æ“ä½œå®Œæˆï¼';
            return;
        }

        const rect = this.canvas.getBoundingClientRect();
        const clickX = event.clientX - rect.left;

        const towerAreaWidth = this.CANVAS_WIDTH / 3;
        let targetTower = -1;
        if (clickX < towerAreaWidth) {
            targetTower = 0;
        } else if (clickX < towerAreaWidth * 2) {
            targetTower = 1;
        } else {
            targetTower = 2;
        }
        
        this.processMove(targetTower);
    }

    processMove(targetTower) {
        const sourceTower = this.selectedTower;

        // 1. æœªé€‰ä¸­æºç›˜æ—¶ (é€‰ä¸­é˜¶æ®µ)
        if (sourceTower === -1) {
            if (this.towers[targetTower].length > 0) {
                // é€‰ä¸­æ–°ç›˜
                this.selectedTower = targetTower;
                this.selectedDiskSize = this.towers[targetTower][this.towers[targetTower].length - 1];
                this.dom.msg.textContent = `å·²é€‰æ‹© ${this.selectedDiskSize} å·ç›˜ (${this.POLE_NAMES[targetTower]} æŸ±)ã€‚ç‚¹å‡»ç›®æ ‡æŸ±å­æˆ–æ–°æºç›˜ã€‚`;
            } else {
                this.dom.msg.textContent = 'è¯¥æŸ±å­æ²¡æœ‰ç›˜å­å¯é€‰æ‹©ã€‚';
            }
        } 
        // 2. å·²é€‰ä¸­æºç›˜æ—¶ (ç§»åŠ¨æˆ–æ›´æ¢æºç›˜é˜¶æ®µ)
        else {
            // å¦‚æœç‚¹å‡»äº†æºæŸ±ï¼Œæˆ–è€…ç›®æ ‡æŸ±å­é¡¶éƒ¨æ²¡æœ‰ç›˜å­/ç›˜å­å¤ªå° (å³å°è¯•ç§»åŠ¨)
            if (targetTower !== sourceTower) {
                
                const diskToMoveSize = this.selectedDiskSize;
                const topDiskOnTargetSize = this.towers[targetTower].length > 0 ? 
                                            this.towers[targetTower][this.towers[targetTower].length - 1] : 
                                            Infinity; 

                // æ±‰è¯ºå¡”è§„åˆ™æ£€æŸ¥
                if (diskToMoveSize < topDiskOnTargetSize) {
                    
                    // ç§»åŠ¨æˆåŠŸ: æ‰§è¡ŒåŠ¨ç”»å’Œæ•°æ®æ›´æ–° (çœç•¥åŠ¨ç”»ä»£ç ï¼Œåªä¿ç•™é€»è¾‘)
                    this.animation = {
                        diskSize: diskToMoveSize,
                        startTower: sourceTower,
                        endTower: targetTower,
                        startPos: this.towers[sourceTower].length - 1, 
                        endPos: this.towers[targetTower].length,      
                        startTime: Date.now()
                    };
                    
                    this.towers[sourceTower].pop(); 
                    this.towers[targetTower].push(diskToMoveSize); 
                    
                    this.moveCount++;
                    this.dom.count.textContent = this.moveCount;
                    this.dom.msg.textContent = `æ­£åœ¨ç§»åŠ¨ ${diskToMoveSize} å·ç›˜ä» ${this.POLE_NAMES[sourceTower]} æŸ±åˆ° ${this.POLE_NAMES[targetTower]} æŸ±...`;

                    // ç§»åŠ¨å®Œæˆåï¼Œé‡ç½®é€‰ä¸­çŠ¶æ€
                    this.selectedTower = -1;
                    this.selectedDiskSize = 0;

                } else {
                    // è¿åè§„åˆ™ï¼Œ**å–æ¶ˆå½“å‰é€‰æ‹©**ï¼Œç„¶åå°è¯•é€‰ä¸­æ–°ç›˜
                    this.dom.msg.textContent = 'âŒ è¿åè§„åˆ™ï¼ä¸èƒ½å°†å¤§ç›˜å­æ”¾åœ¨å°ç›˜å­ä¸Šã€‚è¯·é‡æ–°é€‰æ‹©ã€‚';
                    
                    // å¤±è´¥åï¼Œç«‹å³é‡ç½®é€‰ä¸­çŠ¶æ€
                    this.selectedTower = -1;
                    this.selectedDiskSize = 0;
                }
            } else {
                // 3. å·²é€‰ä¸­æºç›˜ï¼Œä½†ç‚¹å‡»äº†æºç›˜æ‰€åœ¨æŸ±å­ (æ–°é€»è¾‘ï¼šè‡ªåŠ¨å–æ¶ˆé€‰ä¸­ï¼Œå¹¶å°è¯•é€‰ä¸­æ–°ç›˜)
                
                // æ£€æŸ¥æ–°ç‚¹å‡»çš„æŸ±å­ä¸Šæ˜¯å¦æœ‰ç›˜å­å¯ä¾›é€‰æ‹©
                if (this.towers[targetTower].length > 0) {
                    // å–æ¶ˆæ—§çš„é€‰æ‹©
                    this.selectedTower = -1;
                    this.selectedDiskSize = 0;
                    this.dom.msg.textContent = 'å·²å–æ¶ˆæ—§é€‰æ‹©ã€‚';
                    
                    // ç„¶åé€’å½’è°ƒç”¨è‡ªå·±ï¼Œå†æ¬¡å°è¯•å¤„ç†è¿™æ¬¡ç‚¹å‡»ï¼ˆé€‰ä¸­æ–°ç›˜æˆ–æç¤ºæ— ç›˜ï¼‰
                    this.processMove(targetTower);
                } else {
                     // å¦‚æœç‚¹å‡»çš„æ˜¯æºæŸ±ï¼Œä½†æ­¤æ—¶æºæŸ±ç›˜å­å·²è¢«ç§»åŠ¨ï¼Œåˆ™ä»…å–æ¶ˆé€‰ä¸­
                     this.selectedTower = -1;
                     this.selectedDiskSize = 0;
                     this.dom.msg.textContent = 'å·²å–æ¶ˆé€‰æ‹©ã€‚';
                }
            }
        }
    }
    
    // --- è‡ªåŠ¨æ¼”ç®—ç›¸å…³æ–¹æ³• ---

    toggleControls(enabled) {
        this.dom.input.disabled = !enabled;
        this.dom.resetBtn.disabled = !enabled;
        this.dom.solveBtn.disabled = !enabled;
    }

    async solveAutomatically() {
        if (this.isAnimating || this.isSolving) {
            this.dom.msg.textContent = 'æ­£åœ¨æ‰§è¡Œæ“ä½œï¼Œè¯·ç¨å€™ã€‚';
            return;
        }

        this.isSolving = true;
        this.toggleControls(false);
        this.dom.msg.textContent = 'å¼€å§‹è‡ªåŠ¨æ¼”ç®—...';

        this.resetGame(this.diskCount);
        // çŸ­æš‚å»¶è¿Ÿä»¥ç¡®ä¿é‡ç½®æ¸²æŸ“å®Œæˆ
        await new Promise(res => setTimeout(res, 100));

        const moves = [];
        this.generateMoves(this.diskCount, 0, 2, 1, moves);

        for (const move of moves) {
            // ç­‰å¾…ä¸Šä¸€ä¸ªåŠ¨ç”»ç»“æŸ
            while (this.isAnimating) {
                await new Promise(res => setTimeout(res, 50));
            }
            
            this.performMove(move.from, move.to);
            
            // è®¾ç½®æ¯æ¬¡ç§»åŠ¨å¼€å§‹çš„é—´éš”
            await new Promise(res => setTimeout(res, 500));
        }
        
        // ç­‰å¾…æœ€åä¸€ä¸ªåŠ¨ç”»ç»“æŸ
        while (this.isAnimating) {
            await new Promise(res => setTimeout(res, 50));
        }

        this.isSolving = false;
        this.toggleControls(true);
        // èƒœåˆ©æ¶ˆæ¯å°†ç”± checkWin() åœ¨æœ€åä¸€æ¬¡åŠ¨ç”»ç»“æŸæ—¶è®¾ç½®
    }

    generateMoves(n, src, dst, aux, moves) {
        if (n > 0) {
            this.generateMoves(n - 1, src, aux, dst, moves);
            moves.push({ from: src, to: dst });
            this.generateMoves(n - 1, aux, dst, src, moves);
        }
    }

    performMove(fromTower, toTower) {
        const diskToMoveSize = this.towers[fromTower][this.towers[fromTower].length - 1];

        this.isAnimating = true; // æ‰‹åŠ¨å¯åŠ¨åŠ¨ç”»çŠ¶æ€
        this.animation = {
            diskSize: diskToMoveSize,
            startTower: fromTower,
            endTower: toTower,
            startPos: this.towers[fromTower].length - 1,
            endPos: this.towers[toTower].length,
            startTime: Date.now()
        };
        
        // æ›´æ–°æ•°æ®æ¨¡å‹
        this.towers[fromTower].pop();
        this.towers[toTower].push(diskToMoveSize);

        this.moveCount++;
        this.dom.count.textContent = this.moveCount;
        this.dom.msg.textContent = `ç§»åŠ¨ ${diskToMoveSize} å·ç›˜ä» ${this.POLE_NAMES[fromTower]} åˆ° ${this.POLE_NAMES[toTower]}...`;

        // é‡ç½®ç”¨æˆ·äº¤äº’çŠ¶æ€
        this.selectedTower = -1;
        this.selectedDiskSize = 0;
    }
}

const hanoiGame = new HanoiGame();
</script>
</body>
</html>
